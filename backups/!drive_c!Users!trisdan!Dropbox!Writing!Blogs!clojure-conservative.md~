# Why Steve Yegge Calls Clojure Conservative

I read Steve Yegge's Google Plus post <a href="https://plus.google.com/110981030061712822816/posts/KaSKeg4vQtz>"Notes from the Mystery Machine Bus"</a> a few years ago when I wanted to find out what his opinion of Clojure was. It seemed, in retrospect, like Clojure was exactly the language he'd been yearning for all those years when he wrote posts like "Lisp is not an acceptable Lisp": something practical like Common Lisp, but clean like Scheme, and with modern features like namespaces and hash tables built in.

That's why I was somewhat surprised to see him trash Clojure as too conservative in that post, where he introduces a "software-political spectrum" from liberal to conservative and places several languages and technologies on it.

The post is good, but it's really long, so I'll summarize the part that's most relevant to this post. Steve begins by defining "software liberal" and "software conservative" and explaining his own bias as a liberal, he classifies a bunch of concepts as apolitical, conservative, liberal, centrist, conservative-leaning, and liberal-leaning. Then he classifies a bunch of languages according to where they fall on the spectrum, in his opinion. The first time I read this, I was nodding along. Uh-huh, assembly language is batshit liberal. Perl, Ruby, PHP, and shell script are all extremist liberal, with their terse syntax and context-sensitive behaviors. Javascript is hardcore liberal, with its loose prototypal inheritance system and flexible functions. (I'm not so sure modern versions of Visual Basic are liberal; they seem pretty much like Java, but somehow even more verbose.) Python and Common Lisp are liberal, sure, sure. C is moderate-liberal, and C++ and Java, with their strong static type systems, are moderate conservative.

But where's Clojure?

Oh, there it is. Conservative. Alongside Erlang and Pascal.

Like I said, this completely puzzled me the first time I saw it. After all, Clojure has macros. It makes defining DSLs pretty easy. It's dynamically typed. If you go back to the feature classification (as another essay from the Clojure community, arguing that Clojure is not conservative, did), you see that of the conservative features, Clojure has only a single-pass compiler, a software transactional memory system, and purely functinoal data structures. It has the centrist lambdas, exceptions, Just-in-Time compilation, multimethods, declarative data structures (assuming I understood what he meant by that correctly), and literal syntax for data structures, as well as type dispatch in its protocol system. And it has the liberal eval, metaprogramming (macros), dynamic scoping (as an option), emphasizes DSL creation, allows optional parameters, and has thread -local variables and arity-based function overloading.

But I kind of missed the point. This wasn't just a random glob of features classified as "like" and "don't like". There were actual principles involved in Steve's judgment about these things, which I missed. The main thing is that Clojure is a functional language, and Steve lists that as something that becomes conservative if taken far enough. When I first read it, I thought he meant "if taken to Haskell/SML extremes" with the strong static type systems, yet he still classified Clojure as "conservative", even though it's clearly less so than Haskell and even its cousin, Scala (as Steve acknowledges; he puts Scala as "hardcore conservative" and Haskell as "extremist conservative").

Before I go on, I should say that I disagree with Steve's classification of Clojure. I now see where he's coming from, but I still disagree, at least when you solely consider the language. I also dispute his claim that "Clojure's community came pre-populated with highly conservative programmers from the pure functional world, basically Haskell/ML types" (ha ha). Several of the high profile Clojure people are former Java, Python, and Ruby programmers. To be honest, his whole section on why he didn't like Clojure didn't really explain anything for me. I had to apply his framework myself, plus look at some things he said in his follow-up essay <a href="https://plus.google.com/110981030061712822816/posts/iuRbQe6EoiK">"Return of the Mystery Machine Bus"</a>, to make sense of his position.

Steve started his career as an assembly language programmer. Assembly language lets you do basically anything, at the price of being awful to work with. It seems like assembly language programmers get profoundly affected by having all that control, and sometimes they have a hard time giving it up. I had a professor who was also an assembly coder for the DoD, and he had that kind of attitude.

But Steve also recognizes the shortcomings of assembly language. I think he enjoys Ruby and Javascript and Common Lisp because they give you a lot of control, but also take away the parts of assembly language that make it painful by providing namespacing mechanisms, data structure literals, and other high-level code organization features that let you get away from global variables and contiguous blocks of memory that you have to allocate yourself. Steve doesn't want to give up control, but he also doesn't want that non-deterministic context sensitivity that you get with assembly language, and to some extent, Perl, where the same line of code can have different effects depending on the current state of some far-flung part of the system.

Static type systems force you to give up control. They make you pin down your data's type at compile time, so you can't change your mind at runtime. They also constrain the structure of the language and make certain things difficult or impossible. On the other hand, features like Ruby's DSL-making ability or Common Lisp's macros allow the programmer a high degree of control.

Since the words of Bruce Tate on the evils of mutable state were still ringing in my ears at the time, I didn't even consider this, but making everything immutable is a restriction, much like a static type system. You're giving up a certain degree of control. In Java, you can choose whether your classes are mutable or immutable. You can choose to program as if things were immutable, but occasionally mutate them for performance reasons. Python and Ruby make this even easier. Clojure makes everything immutable. The data structures are all mega-optimized persistent structure-sharing immutable data structures, but everything being immutable takes certain options off the table. It's a matter of software-political alignment whether you think those options are an acceptable loss; Bruce Tate thinks yes, Steve Yegge thinks no. This is probably why Erlang joined Clojure in the "conservative" category: Erlang is dynamically typed and not too restrictive in general, but it does force everything to be immutable. This is probably also why Steve classfies Scheme as more conservative than Common Lisp: Scheme goes further towards pure functional programming, and makes more things immutable.

Clojure does actually have mutable state&mdash;atoms, refs, and agents are all ways of managing mutable state. But you can't use them like vars. You have to mutate atoms, refs, and agents in very specific and controlled ways, using transactions, and functions like <code>send</code> and <code>alter</code>, to wrangle them through a purely functional veneer. Clojure does this because atoms, refs, and agents are intended as concurrency mechanisms. You're not supposed to implement an in-place quicksort using an atom containing a vector of atoms; that would be rather painful, because you'd have to wrap all the assignments with calls to <code>swap</code>. You can do it, but the language is telling you it doesn't like that by making it so annoying. Steve mentions that explicit is generally conservative, and implicit is generally liberal; the Clojure way of dealing with mutable state is about as explicit as it gets. He later complains directly about transactions in the follow-up post. 

Clojure also purposely restricts macros. In particular, there are no reader macros. In Common Lisp, you could actually define new syntax, within certain limits. I don't think you can, say, completely reimplement Python on top of Common Lisp using just macros, without writing a parser. But Common Lisp didn't have Clojure's syntax for hash tables and sets, and theoretically, you could use reader macros to add it in. You could use regular macros to make your own C-style for-loop (which you can also do in Clojure), and then use reader macros to make <code>$%^(1 2 3 4)</code> be the syntax for <code>(for i (0 3) (1+ (nth i (1 2 3 4))))</code>. I don't know why you would, but you could. In Clojure, you can't. This was intentional, because Rick Hickey wanted to make it easier for teams to collaborate on a codebase, and this way, no one ever has to remember what <code>$%^(1 2 3 4)</code> actually means, because you can't make it in the first place.. (Steve has his own way of phrasing this, which I'll let you read on your own, but it isn't nearly as charitable as mine.)

So I think those are the main two reasons in the language itself that Steve classifies Clojure as "conservative": lack of/difficulty of using mutable state, and restricted macros. He acknowledged in the follow-up essay that Clojureans don't seem to be afraid of DSLs, and that many of the other additions are decided improvements over Common Lisp and Scheme, but he stood by his "conservative" label, and now I think I understand why.

I don't really agree that all this makes Clojure more conservative than Scheme or Common Lisp, and I definitely don't agree that it's more conservative than Java, at least if you factor in the community. (Java lets you model everything to death with generics, and also lets you cast everything from Object and get an exception at runtime if it's an incompatible type, but the community is clearly in favor of the former.) But I understand why Steve says so now. Besides, I think I'm a little more conservative than he is to begin with; I was brought up on Python, which he puts down as more conservative than Ruby and Javascript, and he also later says that Python is a liberal-ish language with a conservative community. All the languages I like (Javascript, Python, Java, Clojure) are towards the middle part of the spectrum; I'm not that into assembly (who is?), Perl, or PHP at the liberal end, and while I think Ruby is a very nice language, I slightly prefer Python. I respect C, though I don't know if I'd say I like it. I think I would like Lua if I ever tried it. So I think overall I'm more conservative than Steve, even though I'm also not that into Haskell or Scala at the conservative end. I respect them as works of the human mind, but they're very complex, and I'm not sure all that complexity really leads to better programs for most fields of application (maybe for things like automated proof assistants or space station tilt calibration software).

So I still like Clojure, even if it is too conservative for Steve Yegge's taste. And as Steve himself hoped for, his liberal/conservative framework gave me a way to analyze our difference of opinion in a comprehensible way, so that I could understand why our impressions of the language were so different.
